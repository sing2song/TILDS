# 해시테이블



원소가 저장될 자리가 원소의 **값**에 의해 결정되는 자료구조

평균 상수 시간에 삽입, 삭제, 검색

매우 빠른 응답을 요하는 응용에 유용

자료가 많아져도 검색의 효율성이 변하지 않음



bucket - 저장되는 통

slot - 버킷은 통이고 그 안에 담긴 편지의 수가 slot

key - 주소, 저장할 값

hash value = hash function(key) - 우편번호, 저장의 위치값

hash table - bucket의 집합



## hash function(DataStructure1.ppt p260)

key값이 hash function에 의해 저장할 위치가 정해진다.

입력원소가 해시 테이블에 고루 저장되어야한다. 

계산이 간단해야한다.

여러가지 방법이 있으나 가장 대표적인 것은 나누기 방법과 곱하기 방법이다.



## slot

하나의 버킷의 여러값들이 저장되어있다.

같은 장소에 다른 명칭들이 모일 때 이를 동거자(synonym) 이라 하며 동거자가 발생하는 현상을 충돌(collision)이라한다.

고로 **충돌**이 발생하는 것을 전제로한다!

이 부분을 어떻게 해결할 것인가!





## 충돌해결

해결방법에 따라 3가지

[배열] : 하나의 버킷에 하나의 데이터만 저장 가능

1. 선형 탐사법(linear probing) = 선형개방 주소 지정법(open addressing)
2. 이중 해쉬법

[배열+연결리스트] : 하나의 버킷 안에 여러개의 슬롯(데이터) 저장 가능

3. 연결법 = 체인이용법(chainning)





### 선형탐사법

어떻게든 공간안에다가 저장을 하는것!

충돌이 일어나도 주어진 공간안에서 해결한다.

정적인 해쉬테이블(자료의 변동이 별로 없을 때)

이미 다른 레코드가 버킷에 들어 있다면 단순히 **다음 버킷에 기입**하는 방법이다.

해쉬 테이블도 **원형큐(순환큐)**

> 버킷의 상태값

비어있다(EMPTY) : -1

삭제된상태(DELETED) : -2

값이 저장된 상태(0~N)



> 장점

구조가 간단.  검색 효율성이 좋음!!

> 단점

충돌시 전체를 검색해야하는 경우가 발생한다. **무한루프**

극복하는 방법? 많이 만들면 된다 But, 메모리의 낭비가 됨

**그래서 공식사용! 120% 생성하기**

ex) 내가 10개의 데이터를 저장하고 싶을 때 버킷의 개수12개

무조건 빈공간이 생기기 때문에 무한루프불가능!



> 중요한 3가지 방법

**선형조사**, 이차원 조사, 더블 해싱



> 삽입

1. 삽입할 레코드의 해쉬값을 해쉬 함수를 이용하여 구하여 이를 try에 저장

2. while(해쉬 테이블[try]가 비어있지 않을 동안)

     2.1 try = (try+1) % TABLE_SIZE

3. 해쉬 테이블[TRY]에 레코드를 기입



> 검색

1. **검색할 키의 해쉬값을 구하여** try에 저장

2. while(해쉬 테이블[try]가 비어있지 않을 동안)

   2.1 해쉬테이블[try]가 찾고자 하는 레코드이면 리턴

    2.2 아니면 try = (try+1) % TABLE_SIZE

3. 여기까지 오면 찾지 못한 것이므로 실패



-------

## MAP

선형 탐사법을 이용한 MAP만들기

Map : pair형태의 저장 자료구조