### 연결리스트

![image-20210215091429148](C:%5CUsers%5C32153256%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210215091429148.png)

앞에서 얘기한 이부분을 다룰 것이다!



연결리스트는 큰 공간 안에 데이터들이 저장되어있고 이들에게 순서를 부여.

그래서 반드시 **시작점(head)**을 알고있어야한다!!

마지막 데이터는 다음을 가르키는 데이터가 null을 가지고있게된다.

노드는 내 다음번의 주소를 갖고있다.



#### 배열 VS 연결리스트

배열은 삽입, 삭제시 자료의 이동이 일어난다.

연결리스트는 추가되어도 문제가 되지않는다. 논리적 연결만 이어주면 된다.

구조에 따라서 차이점들이 생기게 된다.



#### 연결리스트 종류(단일, 이중, 환형)

단일 연결리스트에서 특정데이터에서 다음으로 이동하는것은 쉬우나 이전데이터로 이동하는 법은 어렵다.

단일은 이동시 ++연산만 가능. 



이중연결리스트는 노드에 앞뒤로 주소를 붙이는 것이다.

이동시 --,++ 연산이 가능해진다.



환형연결리스트는 단일이든 이중이던 상관없다.

단, 마지막 노드가 첫번째 노드를 가리킨다.



### 단일 연결리스트

노드 : 데이터저장소 + 링크(다음 노드의 주소를 저장하는 공간. 링크를 통해 논리적 선형구조 완성!)



#### 구현

단일리스트 기준

1. 노드 정의 //저장타입
2. 연결리스트 구조체 정리 //다음 노드의 주소



노드를 만들기 위해선 두개 데이터를 담을 것이 필요하다.



초기화상태: head는 null, count=0

보통 생성자에서 초기화한다!



> Insert (처음 삽입, 중간 삽입, 뒤 삽입)

ex)

1. 책상[node]을 들고 입실. - 노드를 생성

2. 아무데나 놓는다 - 노드를 초기화(데이터저장, null)

3. 논리적 연결 - 앞에 연결(front insert) 

   3.1 비어있을 때

   3.2 노드가 존재할 때

```java
//1. 비어있는 노드의 판단! head가 곧 새 노드가 된다
if(head==null)
    head=newnode;
    
//2. 노드 연결
newnode.next=head;
head=newnode;
```



- back_insert(뒤 삽입)

1. 노드 생성 및 초기화

2. 연결

   2.1 노드가 비어있을 때

   2.2 노드가 존재할 때 

   ```java
   //마지막 노드를 찾는다!(순회 알고리즘 필요) 
   cur.next==null
   //연결
   cur.next=newnode;
   ```

   





> selectall(선형순회)

순회할 레퍼런스 변수 선언해서 이 변수에 첫번째 노드를 가르키는 것부터 순회가 시작된다.

null값(마지막 순번)이 나올때까지 탐색한다.

```java
//첫번째 노드를 선택
Node cur = head;

//cur를 이동
cur=cur.next;

//언제까지?
cur==null => 이동을 멈춰야한다!
```



#### 📌박싱 언박싱

**박싱(boxing)은 기본 자료형의 데이터를 래퍼(wrapper) 클래스의 객체로 만드는 과정**을 의미하며,
**언박싱(un** **boxing)은 래퍼(wrapper) 클래스의 데이터를 기본 자료형으로 얻어내는 과정**을 말한다.

select부분에서 언박싱이 일어났다!

data는 Object로 생성했었는데 int로 언박싱함

```java
while(cur!=null) {
    //----------------------
    int data = (int)cur.data;//정수라고 가정	언박싱!(자동으로 일어남) : 기본형타입 = 레퍼런스타입일때 자동적으로 일어남
    if(data==(int)key) {//key값을 비교해서 문제 확인
        return cur;
    }
    //----------------------
    cur=cur.next;//이동시키기
}
```



> delete(처음 삭제, 중간 삭제, 맨뒤 삭제)

1. 삭제할 노드를 찾는다

2. check! 

   2.1 노드가 없는경우  - 연산이 들어가면 안된다!

   2.2 삭제 후 노드가 없을 경우와 있을 경우(연산이 똑같아서 구분할 필요는없다)


- 처음 삭제

```java
public boolean front_Insert(Object data) {//마지막에 넣은것이 앞에
		Node newnode = new Node(data);
		
		if(head==null) {
			head=newnode;//head가 곧 새 노드가 된다.
		}else {
			//새로운 노드의 next영역에 연결해준다.
			newnode.next=head;
			head=newnode;
		}
		size++;
		return true;		
	}

```



- 마지막 삭제

꼬리 찾기와 비슷하다. 하지만 꼬리를 찾아도 그 전의 노드 값을 알수있는 방법이 없다!!

그래서 꼬리를 찾는 것보다 **이전 노드(prev)를 찾는 것이 핵심이다!**

```java
while(del.next!=null) {
    prev=del;//prev가 del의 뒤를 쫓아간다.
    del=del.next;//위치이동
}
prev.next=null;//prev.next=del.next=>null
```



> 노드가 한 개일 때의 삭제

node가 아니라 head가 가르키는 값이 달라져야한다.

```java
head=null;
```





#### 과제

> 중간 삽입

1. 노드생성 및 초기화

2. 그림에 있는 2개의 연결흐름 작성
   - 새로운 노드의 연결을 먼저!
3. size 1 증가

4. true 반환

- 연결에 대한 다른 상황을 생각!

  - 노드가 비어있을때(존재할 수 없는 환경)

  - cur의 위치가 마지막 노드일때